# 第一章 云原生应用和微服务简介

## 云计算简介

> 云计算服务可划分为以下几种类型:

* SaaS: Software as a Serivce，软件即服务。提供给终端用户可以直接食用的应用程序。
* PaaS: Platform as a Service，平台即服务。提供给终端用户工具和服务的集合，对想要快速构建应用程序或要快速将应用程序部署到生产环境，而不关心底层硬件细节的用户提供服务。
* IaaS: Infrastructure as a Service，设施设施即服务。针对想要建立自己的商业模式，而且需要定制的客户提供服务。

> 云计算，作为一个技术栈，可以这样解释:

* 通常谈及云计算指代的是一个技术栈，涵盖广泛的服务，其中很多服务都是建立在其他服务基础之上的，例如云
* 云计算模式被认为是不同的可配置的计算资源的集合\(如服务器、数据库和存储等等\)，它们之间互相通信，几乎可以在无需人为监督的情况下提供给用户。

### 软件即服务

> SaaS 要点

* SaaS 使用户能够通过浏览器访问由提供商提供的，基于互联网提供服务的软件。这些服务是订阅式的，也称为按需软件。
* 提供 Saas 的产品包括: Google Docs 套件、Oracle CRM、微软 Office 365 等等。
* SaaS 可以进一步细分为垂直 SaaS 和水平 SaaS。前者侧重于医疗保健和农业等特定行业的需求；后者专注于软件行业，例如人力资源和销售。
* SaaS 基本上是针对那些想要快速获取现成软件和应用的组织，这些应用即便是非技术人员也能理解和使用。通常，组织可以根据用途和预算选择不同的套餐。此外，终端用户也可以从任何可以连接到互联网的角落，访问这些应用。

### 平台即服务

> PaaS 要点

* 对于 PaSs 产品，组织或企业无需担心其内部应用程序的硬件和软件基础设施的管理问题。
* PaaS 的最大长处在于可以为开发团队\(本地或是远程\)提供在通用框架下，提供有效构建、测试和部署应用程序的能力，其中底层硬件和软件有 PaaS 服务供应商提供。
* PaaS 供应商提供平台，同时提供围绕该平台的服务。
* PaaS 供应商包括 Amazon Web Servies\(AWS Elastic Beanstalk\)、微软 Azure\(Azure Websites\)、Google App Engine 和 Oracle\(Big Data Cloud Service\)

## 云原生的概念

> 云原生是一种团队、文化和技术组织形式，利用自动化工具和架构来管理软件复杂度和加速软件交付。
>
> * **结果导向和团队合作**: 云原生的方法将一个大问题分解成众多的小问题，从而使每个团队都能专注于各自的部分。
>
> * **减少重复工作**: 自动化减少了困难、繁杂和重复的手动工作量，并减少了停机时间，这将使得系统更有效率。
>
> * **可靠而高效的应用程序基础设施**: 自动化可以对不同环境\(无论是开发、阶段发布还是生产\)中的部署做更多地控制，还可以处理意外事故。自动化构建不仅有助于正常部署，而且在灾难恢复时，也可以使重新部署更容易。
>
> * **应用程序洞察**: 为云原生应用程序构建的工具可以为应用程序提供更多洞察，从而使调试、故障排查和审计更容易。
>
> * **高效可靠的安全性**: 每个应用程序都会关注安全性，确保可靠的身份验证。孕育安盛为开发人员提供了多种确保应用程序安全性的方式。
>
> * **经济高效的系统**: 使用云管理和部署应用程序可以有效地利用资源，包括应用程序发布，通过减少资源浪费使系统花费更合理。

### 云原生为何物？为何重要？

> 云原生是一个宽泛的术语，它可以充分利用不同的技术，如基础架构自动化或中间件开发、支持服务等，这些功能都是属于应用交付周期的的一部分。云原生方法包括频繁的版本发布\(无Bug、稳定\)，以及根据业务需求扩展应用程序。
>
> 使用云原生方法，可以系统的实现应用程序构建目标。理想的云原生架构应具有自动化和组合功能，这些自动化技术还应实现跨平台管理和部署应用程序。
>
> 云原生架构还应该具有其他几个特性，如稳定的日志记录、应用程序和基础架构监控，以确保应用程序正常运行。
>
> 云原生方法能够帮助开发人员使用例如 Docker 等工具，在不同的平台上轻易地创建和销毁应用程序。

### 云原生运行时环境

> 当软件从一个计算环境迁移到另一个计算环境时，该如何使其可靠运行？最佳解决方案就是使用容器，Kubernetes 已经成为容器服务的代名词。
>
> 在容器运行时，需要注意以下几点:
>
> * **管理容器状态和高可用性**: 保持容器状态的同时，还因该能够业务需求进行扩展。
> * **成本体现和分析**: 容器可以根据业务预算控制资源管理，并在很大程度上降低成本。
> * **环境隔离**: 在容器内运行的每个进程都被隔离在该容器中。
> * **跨集群的负载均衡**: 应用流量由容器集群处理，在容器内均匀重定向，这将增加应用程序最大相应数量，并维持高可用性
> * **调试和灾难恢复**: 要有正确的工具用以监控应用程序运行状况，以避免生产系统意外停机，提高生产系统可用性。

### 云原生架构

> 云原生架构类似于传统应用架构，但在云原生架构下，应该考虑一些特性，如十二要素应用程序\(应用程序开发模式的集合\)、微服务\(将单体业务系统分解为独立可部署服务\)、自服务敏捷基础设施\(自服务平台\)、基于 API 的协作\(通过 API 进行服务之间的交互\)和抗脆弱性\(自我实现和加强的应用程序\)。
>
> 首先，探讨下什么是**微服务**。微服务是一个更宽泛的术语，指将大型应用程序分解成更小的模块，分别开发，直至发布。这种方法不仅有助于有效的管理每个模块，而且还可以帮助我们发现服务底层本身的问题。以下是为服务的一些关键部分:
>
> * **用户友好的界面**: 微服务之间可以实现明确的分离。微服务的版本控制可以更好地对 API 进行控制，为消费者和生产者提供更大的自由度。
> * **跨平台部署和 API 管理**: 由于每个微服务都是一个单独的实体，因此可以更新单个微服务而不用更改其他服务，同时也可以轻易实现服务回滚。这意味着用来部署微服务的工件应该兼容不同的 API 和数据模式。这些 API 必须在不同的平台上测试，并且测试结果应该在不同的团队，即运维、开发人员之间共享，大家共同维护一个集中的控制系统。
> * **应用灵活性**: 开发的微服务应该能够处理所有请求并做出响应，而不管请求的种类如何，包括可能的错误输入或无效请求。微服务也应该能够处理意外的负载请求，并进行适当的响应。所以，应当对未服务进行独立测试和集成测试。
> * **微服务的分布**: 最好将服务分为小块服务，以便单独跟踪和开发，最终组合起来形成一个微服务。这种技术使得微服务开发更稳定、更有效率。
>
> 下图展示了一个云原生应用程序的高级架构:
>
> ![](/img/01.云原生应用程序的高级架构.png)
>
> 在理想情况下，应用程序体系结构应该从两三个服务开始，然后通过不断更新版本进行扩展。

### 微服务是一个新概念吗

> 微服务的概念由来已久，它是一种用来划分大型系统中不同组件边界的架构模式。所有的微服务都以相似的方式工作，然后将不同的服务链接起来，根据请求的类型处理特定事务的数据流。
>
> 下图说明了微服务的体系结构:
>
> ![](/img/01.微服务的体系结构.png)

### 为什么说 Python 是云原生微服务开发的最佳选择

> * 可读性
> * 库和社区
> * 交互模式
> * 可扩展

## 理解十二要素应用

> 构建云原生应用程序时需要考虑的几个方面:
>
> * 使用详实的设计，尽量自动化以降低时间成本和花费
> * 在不同环境\(如阶段发布和生产\)和不同平台\(如 Linux 和 Winodws\)中，应用程序的可移植性
> * 使用适用于云平台的应用程序，了解资源分配和管理
> * 在一致的环境中，通过持续交付/部署来减少错误，从而最大限度地保障软件发布的灵活性。
> * 通过最少的监督和设计灾难恢复架构来扩展应用程序，实现高可用性。
>
> 十二个要素中，有许多要素是相互影响的。通过强调声明性配置，以关注速度、安全性和规模。十二要素应用程序的基本特征如下:
>
> * **基准代码**: 每份部署代码都使用版本控制追踪，并在不同平台中部署多个实例。
> * **依赖管理**: 应用程序应该先是声明依赖关系，并使用工具来单独管理依赖，例如 Bundler、pip 和   Maven 等等。
> * **定义配置**: 不同环境中的配置\(例如环境变量\)可能不同，例如开发环境、预发布环境和生产环境应该在操作系统级定义。
> * **后端服务**: 所有资源都要被当做应用程序自身的一部分对待。例如数据库、消息队列这样的后端服务应当被当做附加资源来看待，在所有环境中以相同的方式使用。
> * **构建、发布、运行阶段隔离**: 包括构建组件、绑定配置，根据绑定的组件和配置文件启动一个或多个实例。
> * **进程无状态**: 以一个或多个无状态进程运行应用\(例如 master 和 worker\)，进程实例之间不共享任何内容。
> * **服务端口绑定**: 应用程序应当自包含，如果有任何需要对外暴露的服务，应当使用端口绑定的形式来完成\(首选 HTTP\)
> * **扩容无状态进程**: 该架构应该强调基础平台中的无状态进程管理，而不是实现更复杂的应用程序。
> * **进程状态管理**: 进程可以在极短的时间内迅速成倍增加，随后立即正常关闭。在这些确保了快速扩展、变更部署和灾难恢复的能力。
> * **持续发布/部署用于生产**: 尽可能的保持在开发、阶段发布或生产阶段环境的相似。这样可以确保在不同环境下获得类似的结果，确保从开发到产品的交付顺利。
> * **日志即事件流**: 不论是平台日志还是应用日志都很重要，这些日志都有助于了解应用的活动状况。通过各类归集服务，确保能够正常收集、汇聚、索引和分析不同环境下\(最好是生产环境\)的事件。
> * **作为一次性进程的临时任务\(Ad hoc tasks\)**: 在云原生方案中，作为版本发布一部分的管理任务\(例如数据库迁移\)，应当作为一次性进程运行\(即执行完即退出\)，而不是像通常应用那样长时间运行。
>
> 考虑以上标准，并使用稳定的工程接口集成应用程序，就是说，通过无状态框架设计的运用，以便发布程序能够适应云端要求。Python 通过其固有的、习惯先于配置\(tradition-over-setup\)的方式革新了应用系统，加速了 Web 开发。

## 设置 Python 环境

> 创建账号指南
>
> * GitHub 用于源代码管理，参考:
>   * [https://medium.com/appliedcode/setup-github-account-9a5ec918bcc1](https://medium.com/appliedcode/setup-github-account-9a5ec918bcc1)
> * AWS 和 Azure 账号用于应用部署，参考:
>   * AWS:[https://medium.com/appliedcode/setup-aws-account-1727ce89353e](https://medium.com/appliedcode/setup-aws-account-1727ce89353e.)
>
>   * Azure:[https://medium.com/appliedcode/setup-microsoft-azure-account-cbd635ebf14b](https://medium.com/appliedcode/setup-microsoft-azure-account-cbd635ebf14b)

### 安装 Git

> Git\(https://git-scm.com\)是一款免费的开源分布式版本控制系统，旨在快速高效的处理所有小型或大型项目。
>
> 下略……

#### 安装和配置Python

> 下略……

### 熟悉 GitHub 和 Git 命令

> 此处书中分别讲了几个常见命令，但看起来比较混乱，还是从别处摘抄写别人的东西吧。
>
> 这里主要参考 [https://www.cnblogs.com/wuer888/p/7655856.html](https://www.cnblogs.com/wuer888/p/7655856.html)
> 基本步骤如下:
> 1. 在 github.com 上新建名为 test 的 Respositories，假设 url 为 https://github.com/heroage/test
> 2. 本地新建软件仓库，并添加远程仓库
>    ```
>    1 software@debian:~$ mkdir test
>    2 software@debian:~$ cd test/
>    3 software@debian:test~/t$ ls
>    4 software@debian:~/test$ git init
>    5 Initialized empty Git repository in /home/software/test/.git/
>    6 software@debian:~/test$ git remote add https://github.com/heroage/test/.git
>    ```
> 3. 向本地 Respositories 提交修改的文件
>    ```
>    1 software@debian:~/test$ echo "our first git repository" >> file
>    2 software@debian:~/test$ ls
>    3 file
>    4 software@debian:~/test$ git add file
>    5 software@debian:~/test$ git commit -m "the first file to commit" file
>    6 [master (root-commit) 0c72641] the first file to commit
>    7  1 files changed, 1 insertions(+), 0 deletions(-)
>    8  create mode 100644 file
>    9 software@debian:~/test$ 
>    ```
>
>    > **命令解释**  
>    > 我们在仓库中新建了一个文件file，作为我们的示例文件。
>    >
>    > 第4行：将file文件的信息添加到git仓库的索引库中，并没有真正添加到库。当然上例中的file文件只是我们的示例，它是一个路径，可以是文件，也可以是目录。
>    >
>    > 第5行：将索引库中的内容向git仓库进行提交。这步之后文件file才算真正提交到拉git仓库中。双引号中的内容是根据每次修改的不同内容，根据实际情况去填写。
>    >
>    > 　　git commit -a -m ""
>    >
>    > 　　git commit -am ""
>    >
>    > 这条命令可以一次性提交修改的 Respositories 文件\(即已经 add 过的文件\)。
> 4. 将本地软件仓库内容推送到远端软件仓库
>    ```
>    1 software@debian:~/test$ git push origin master
>    2 heroage@sina.com's password: 
>    3 Everything up-to-date
>    4 software@debian:~/test$ 
>    ```
>
>    > 第1行:将本地master分支跟踪到远程分支，在 git 仓库建立之初就会有一个默认的 master 分支，当然你如果建立了其他分支，也可以用同样的方法去跟踪。
> 5. 测试
>    ```
>     1 software@debian:~/test$ git remote show origin
>     2 heroage@sina.com's password: 
>     3 * remote origin
>     4   Fetch URL: https://github.com/heroage/test/.git
>     5   Push  URL: https://github.com/heroage/test/.git
>     6   HEAD branch: master
>     7   Remote branch:
>     8     master tracked
>     9   Local ref configured for 'git push':
>    10     master pushes to master (up to date)
>    11 software@debian:~/test$ 
>    ```
> 6. 在其他计算机执行 clone
>    ```
>     1 root@test-VirtualBox:~# ls
>     2 bin  gittest  read_temp
>     3 root@test-VirtualBox:~# git clone https://github.com/heroage/test/.git
>     4 Cloning into test...
>     5 heroage@sina.com's password: 
>     6 remote: Counting objects: 9, done.
>     7 remote: Compressing objects: 100% (3/3), done.
>     8 remote: Total 9 (delta 0), reused 0 (delta 0)
>     9 Receiving objects: 100% (9/9), done.
>    10 root@test-VirtualBox:~# ls
>    11 bin  gittest  read_temp  test
>    12 root@test-VirtualBox:~# cd test/
>    13 root@test-VirtualBox:~/test# ls
>    14 file
>    15 root@test-VirtualBox:~/test# 
>    ```



